grammar de.uniba.swt.expr.BahnExpr with org.eclipse.xtext.common.Terminals

generate bahnexpr "http://www.uniba.de/swt/expr/BahnExpr"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

BahnExpr:
	{BahnExpr} (decls+=FuncDecl)*
;

FuncDecl:
	'def' name=ID ('()' | '(' paramDecls+=ParamDecl (',' paramDecls+=ParamDecl)* ')')
		stmtList=StatementList
	'end'
;

StatementList:
	{StatementList} (stmts+=Statement)*
;

Statement:
	SelectionStmt | IterationStmt | VarDeclStmt | AssignmentStmt | FunctionCallStmt | ReturnStmt
;

SelectionStmt returns Statement:
	{SelectionStmt} 'if' expr=Expression
	thenStmts=StatementList
	(=>'else'
		elseStmts=StatementList
	)?
	'end'
;

IterationStmt returns Statement:
	{IterationStmt} 'for' var=IterationVarDecl 'in' referenceExpr=ValuedReferenceExpr
		stmts=StatementList
	'end'
;

IterationVarDecl:
	type=ValueType name=ID
;

VarDeclStmt returns Statement:
	{VarDeclStmt} type=ValueType name=ID ('[' cardinality=Expression ']')? assignment=VariableAssignment
;

ParamDecl:
	type=ValueType name=ID
;

AssignmentStmt returns Statement:
	{AssignmentStmt} referenceExpr=ValuedReferenceExpr assignment=VariableAssignment
;

FunctionCallStmt returns Statement:
	{FunctionCallStmt} expr=FunctionCallExpr
;

ReturnStmt returns Statement:
	{ReturnStmt}'return' expr=Expression
;

VariableAssignment:
	'=' ('{' arrExprs+=Expression (',' arrExprs+=Expression)* '}' | expr=Expression)
;

Expression returns Expression:
	LogicalOrExpr
; 

LogicalOrExpr returns Expression:
	{LogicalOrExpr}leftExpr=LogicalAndExpr (ops+=OrOp rightExprs+=LogicalAndExpr)* 	
;

LogicalAndExpr returns Expression:
	{LogicalAndExpr}leftExpr=EqualityExpr (ops+=AndOp rightExprs+=EqualityExpr)*
;

EqualityExpr returns Expression:
	{EqualityExpr}leftExpr=RelationalExpr (ops+=EqualityOp rightExprs+=RelationalExpr)*
;

RelationalExpr returns Expression:
	{RelationalExpr}leftExpr=AdditiveExpr (ops+=RelationalOp rightExprs+=AdditiveExpr)*
;

AdditiveExpr returns Expression:
	{AdditiveExpr}leftExpr=MultiplicativeExpr (ops+=AddSubOp rightExprs+=MultiplicativeExpr)*
;

MultiplicativeExpr returns Expression:
	{MultiplicativeExpr}leftExpr=UnaryExpr (ops+=MulDivOp rightExprs+=UnaryExpr)*
;

UnaryExpr returns Expression:
	{UnaryExpr}op=UnaryOp expr=UnaryExpr
	| PrimaryExpr
;

PrimaryExpr:
	ParenthesizedExpr
	| LiteralExpr
	| ValuedReferenceExpr
	| FunctionCallExpr
;

ParenthesizedExpr:
	'(' expr=Expression ')'
;

LiteralExpr:
	BooleanLiteral
	| NumberLiteral
	| StringLiteral
	| NullLiteral
;

ValuedReferenceExpr:
	name=ID 
		('['indices+=Expression']')* 
		('.' propRef=ValuedReferenceExpr)?
;

FunctionCallExpr:
	name=ID
	('()' | '(' params+=Expression (',' params+=Expression)* ')')
;

BooleanLiteral returns LiteralExpr:
	{BooleanLiteral} boolValue=BOOLEAN
;

NumberLiteral:
	{NumberLiteral} value=NUMBER
;

StringLiteral:
	{StringLiteral} value=STRING
;

NullLiteral:
	'nil'
;

enum ValueType:
	INT_TYPE='int' | FLOAT_TYPE = 'float' | BOOLEAN_TYPE = 'bool' | STRING_TYPE = 'string' | OBJECT_TYPE = 'var'
;

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;

enum AddSubOp returns OperatorType:
	PLUS = '+' | MINUS = '-'
;

enum MulDivOp returns OperatorType:
	MULTIPLY = '*' | DIVISION = '/'
;

enum UnaryOp:
	NOT='!' | NEGATION="-"	
;

enum OrOp returns OperatorType:
	OR = '||'
;

enum AndOp returns OperatorType:
	AND = '&&'
;

enum EqualityOp returns OperatorType:
	EQUAL='==' | NOT_EQUAL='!='
;

enum RelationalOp returns OperatorType:
	GREATER='>' | LESS='<' | GREATER_OR_EQUAL='>=' | LES_OR_EQUAL='<='
;

NUMBER hidden():
	(INT ('.' INT)?)
;

@Override 
terminal SL_COMMENT : '#' !('\n'|'\r')* ('\r'? '\n')?;

@Override
terminal STRING returns ecore::EString:
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"';