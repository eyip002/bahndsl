grammar de.uniba.swt.dsl.Bahn with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate bahn "http://www.uniba.de/swt/dsl/Bahn"


RootModule:
	'module' name=ID
		(properties+=ModuleProperty)*
	'end';
	
ModuleProperty:
	AspectsProperty 
	| BoardsProperty 
	| SegmentsProperty 
	| SignalsProperty 
	| PointsProperty 
	| PeripheralsProperty
	| BlocksProperty
	| CrossingsProperty
	| TrainsProperty 
	| LayoutProperty 
	| PlatformProperty
//	| RouteProperty
	| FuncDecl
	;

AspectsProperty :
	{AspectsProperty} 'aspects'
		(items+=AspectElement)*
	'end';
BoardsProperty :
	{BoardsProperty} 'boards'
		(items+=BoardElement)*
	'end';
SegmentsProperty :
	'segments' board=[BoardElement]
		(items+=SegmentElement)*
	'end';
SignalsProperty :
	'signals' board=[BoardElement]
		(items+=SignalElement)*
	'end';
PointsProperty :
	'points' board=[BoardElement]
		(items+=PointElement)*
	'end';
PeripheralsProperty:
	'peripherals' board=[BoardElement]
		(items+=SignalElement)*
	'end';
BlocksProperty :
	{BlocksProperty} 'blocks'
		(items+=BlockElement)*
	'end';
CrossingsProperty:
    'crossings'
		(items+=CrossingElement)*
	'end';
PlatformProperty :
	{PlatformProperty} 'platforms'
		(items+=BlockElement)*
	'end';
TrainsProperty :
	{TrainsProperty} 'trains'
		(items+=TrainElement)*
	'end';
LayoutProperty :
	{LayoutProperty} 'layout'
		(items+=LayoutElement)*
	'end';
/*
RouteProperty:
	{RouteProperty} 'routes'
		(items+=RouteElement)*
	'end';
RouteElement:
	name=ID 
	'source' source=[SignalElement] 
	'destination' destination=[SignalElement]
	'path' (segments+=[SegmentElement])* 'end'
	'points' (points+=RoutePoint)* 'end'
	'signals' (signals+=[SignalElement])* 'end'
	'conflicts' (conflicts+=[RouteElement])* 'end'
;
*/

RoutePoint:
	point=[PointElement] aspect=PointAspectType
;

GetFuncExpr returns BehaviourExpr:
	{GetFuncExpr} 'get'
	(
		(signal?='signal' expr=PrimaryExpr)
		|
		(point?='point' expr=PrimaryExpr)
		|
		(route?='route' 'from' srcSignalExpr=PrimaryExpr 'to' destSignalExpr=PrimaryExpr)
	)
;

WaitFuncExpr returns BehaviourExpr:
	{WaitFuncExpr} 'wait' 'for' value=INT timeSpan=TimeSpanType
;

GrantRouteFuncExpr returns BehaviourExpr:
	{GrantRouteFuncExpr} 'grant' routeExpr=PrimaryExpr 'to' trainExpr=PrimaryExpr
;

SetAspectFuncExpr returns BehaviourExpr:
	{SetAspectFuncExpr} 
	'set' 
	(
		(signal?='signal' expr=PrimaryExpr 'to' aspectId=PrimaryExpr)
		|
		(point?='point' expr=PrimaryExpr 'to' pointAspectType=PointAspectType)
	)
;

enum TimeSpanType:
	SECONDS = 'seconds' | MINUTES = 'minutes' | HOURS = 'hours'
;

PointAspectLiteral:
	value=PointAspectType
;
		
enum TrainType:
	CARGO='cargo' | PASSENGER='passenger'
;

AspectElement :
	name=ID value=HEX
;

BoardElement :
	name=ID uniqueId=HEX ('features' (features+=BoardFeatureElement)+ 'end')?
;

BoardFeatureElement:
	number=HEX ':' value=HEX
;

SegmentElement :
	name=ID address=HEX 'length' length=Length
;

SignalElement :
	name=ID number=HEX 'aspects' aspects=SignalAspectsElement 'end' 'initial' initial=[AspectElement] 
;

SignalAspectsElement:
	ReferenceSignalAspectsElement | OverrideSignalAspectsElement
;

ReferenceSignalAspectsElement:
	(aspects+=[AspectElement])+
;

OverrideSignalAspectsElement:
	(aspects+=AspectElement)+
;

PointElement:
	name=ID number=HEX 
		'segment' mainSeg=[SegmentElement]
		'normal' normalValue=HEX
		'reverse' reverseValue=HEX 
		'initial' initial=PointAspectType
;

enum PointAspectType:
	NORMAL = 'normal' | REVERSE = 'reverse'
;

BlockElement:
	name=ID 
		('overlap' overlaps+=[SegmentElement])?
		'main' mainSeg=[SegmentElement] 
		('overlap' overlaps+=[SegmentElement])?
		('trains' (trainTypes+=TrainType)+ 'end')?
;

CrossingElement:
    name=ID 'segment' mainSeg=[SegmentElement]
;

TrainElement :
	name=ID address=HEX 
		'steps' steps=INT
		('calibration' (calibrations+=INT)+ 'end')? &
		('length' length=Length)? &
		('weight' weight=Weight)? &
		('type' type=TrainType)? &
		('peripherals' (peripherals+=TrainPeripheral)+ 'end')?
;

TrainPeripheral:
	name=ID 'bit' bit=INT 'initial' initial=INT
;

TrackSection:
	BlockElement | PointElement | CrossingElement
;

LayoutElement :
	blocks+=LayoutReference (connectors+=('--'|'->') blocks+=LayoutReference)*
;

LayoutReference:
	elem=[TrackSection] notSignal?='.' prop=ConnectorProp
	|
	elem=[SignalElement]
;

enum ConnectorProp:
    STEM='stem' | STRAIGHT='straight' | SIDE='side' | DOWN='down' | UP='up' | DOWN1='down1' | DOWN2='down2' | UP1='up1' | UP2='up2'
;

Length:
	value=NUMBER unit=LengthUnit
;

enum LengthUnit:
	CENTIMETRE = 'cm' | METRE = 'm' | KILOMETRE = 'km'
;

Weight:
	value=NUMBER unit=WeightUnit
;

enum WeightUnit:
	GRAM = 'g' | KILOGRAM = 'kg'| TON = 't'
;


FuncDecl:
	'def' name=ID ('()' | '(' paramDecls+=ParamDecl (',' paramDecls+=ParamDecl)* ')') (return?=':' returnType=DataType returnArray?='[]'?)?
		stmtList=StatementList
	'end'
;

StatementList:
	{StatementList} (stmts+=Statement)*
;

Statement:
	SelectionStmt | IterationStmt | VarDeclStmt | AssignmentStmt | FunctionCallStmt | ReturnStmt
;

SelectionStmt returns Statement:
	{SelectionStmt} 'if' expr=Expression
	thenStmts=StatementList
	(=>'else'
		elseStmts=StatementList
	)?
	'end'
;

IterationStmt returns Statement:
	{IterationStmt} 'for' var=VarDecl 'in' referenceExpr=ValuedReferenceExpr
		stmts=StatementList
	'end'
;

VarDeclStmt returns Statement:
	{VarDeclStmt} decl=VarDecl assignment=VariableAssignment
;

VarDecl:
	{VarDecl} type=DataType name=ID (array?='[' cardinality=Expression ']')?
;

ParamDecl:
	{ParamDecl} type=DataType name=ID array?='[]'?
;

RefVarDecl:
	VarDecl | ParamDecl
;

AssignmentStmt returns Statement:
	{AssignmentStmt} referenceExpr=ValuedReferenceExpr assignment=VariableAssignment
;

FunctionCallStmt returns Statement:
	{FunctionCallStmt} expr=FunctionCallExpr
;

ReturnStmt returns Statement:
	{ReturnStmt}'return' expr=Expression
;

VariableAssignment:
	'=' ('{' arrExprs+=Expression (',' arrExprs+=Expression)* '}' | expr=Expression)
;

Expression:
	LogicalOrExpr
;

LogicalOrExpr returns OpExpression:
	LogicalAndExpr ({OpExpression.leftExpr=current} op=OrOp rightExpr=LogicalAndExpr)*
;

LogicalAndExpr returns OpExpression:
	EqualityExpr ({OpExpression.leftExpr=current} op=AndOp rightExpr=EqualityExpr)*
;

EqualityExpr returns OpExpression:
	BEqualityExpr ({OpExpression.leftExpr=current} op=EqualityOp rightExpr=BEqualityExpr)*
;


BEqualityExpr returns OpExpression:
	RelationalExpr ({BEqualityExpr.leftExpr=current} suffix=BEqualityExprSuffix)?
;

BEqualityExprSuffix:
	'is' isNot?='not'?
	(
		rightExpr=PrimaryExpr
	|
		routeAvailable?='available'
	|
		occupied?='occupied' (by?='by' rightExpr=PrimaryExpr)?
	)
;


RelationalExpr returns OpExpression:
	AdditiveExpr ({OpExpression.leftExpr=current} op=RelationalOp rightExpr=AdditiveExpr)*
;

AdditiveExpr returns OpExpression:
	MultiplicativeExpr ({OpExpression.leftExpr=current} op=PlusMinusOp rightExpr=MultiplicativeExpr)*
;

MultiplicativeExpr returns OpExpression:
	PrimaryExpr ({OpExpression.leftExpr=current} op=MulDivOp rightExpr=PrimaryExpr)*
;

PrimaryExpr:
    UnaryExpr
	| ParenthesizedExpr
	| LiteralExpr 
	| ValuedReferenceExpr
	| FunctionCallExpr
;

UnaryExpr:
	{UnaryExpr} '!' expr=PrimaryExpr
;

ParenthesizedExpr:
	'(' expr=Expression ')'
;

LiteralExpr:
	BooleanLiteral
	| NumberLiteral
	| HexLiteral
	| StringLiteral
	| NullLiteral
	| PointAspectLiteral
;

ValuedReferenceExpr:
	decl=[RefVarDecl]
		('['indices+=Expression']')*
		('.' propRef=ValuedReferenceExpr)?
;

FunctionCallExpr:
	{FunctionCallExpr} decl=[FuncDecl] ('()' | '(' params+=Expression (',' params+=Expression)* ')')
	| BehaviourExpr
;

BehaviourExpr:
	GetFuncExpr | WaitFuncExpr | GrantRouteFuncExpr | SetAspectFuncExpr
;

BooleanLiteral returns LiteralExpr:
	{BooleanLiteral} boolValue=BOOLEAN
;

NumberLiteral:
	{NumberLiteral} value=NUMBER
;

HexLiteral:
	{HexLiteral} value=HEX
;

StringLiteral:
	{StringLiteral} value=STRING
;

NullLiteral:
	{NullLiteral} 'nil'
;

enum DataType:
	INT_TYPE='int' | FLOAT_TYPE = 'float' | BOOLEAN_TYPE = 'bool' | STRING_TYPE = 'string' | OBJECT_TYPE = 'var'
;

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;

enum PlusMinusOp returns OperatorType:
	PLUS = '+' | MINUS = '-'
;

enum MulDivOp returns OperatorType:
	MULTIPLY = '*' | DIVISION = '/'
;

enum OrOp returns OperatorType:
	OR = '||'
;

enum AndOp returns OperatorType:
	AND = '&&'
;

enum EqualityOp returns OperatorType:
	EQUAL='==' | NOT_EQUAL='!='
;

enum RelationalOp returns OperatorType:
	GREATER='>' | LESS='<' | GREATER_OR_EQUAL='>=' | LES_OR_EQUAL='<='
;

NUMBER returns ecore::EDouble:
	'-'? INT ('.' INT)?
;

terminal HEX returns ecore::EString:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')+;

@Override
terminal SL_COMMENT : '#' !('\n'|'\r')* ('\r'? '\n')?;

@Override
terminal STRING returns ecore::EString:
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"';