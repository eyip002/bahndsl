def interlocking(var table, var srcSignal, var destSignal, var train)
    var route = exec find_route(table, srcSignal, destSignal)
    if route == nil
        return nil
    end

    bool not_grantable = exec route_is_unavailable_or_conflicted(route)
    if not_grantable
        return nil
    end

    bool is_clear = exec route_is_clear(route, train)
    if !is_clear
        return nil
    end

    # block route
    route.train = train

    # set points and signals
    exec set_route_points_signals(route)

    return route
end

def route_is_unavailable_or_conflicted(var route)
    # Check if the route has been granted (unavailable)
    if route.train == nil
        return true
    end

    # Check conflicts
    for var item in route.conflicts
        if item.train != nil
            return true
        end
    end

    return false
end

def route_is_clear(var route, var train)
    # Signal at the route source has to be red (stop aspect)
    if route.source.aspect == "red"
        return false
    end

    # Signals of tracks that intersect the route have to be red (stop aspect)
    # TODO find list of flank signals

    # All track segments on the route have to be clear
    int index = 0
    for var segment in route.path
        if exec is_segment_occupied(segment)
            # Only the first track segment can be occupied, and only by the requesting train
            if index == 0 && exec is_segment_occupied_by_train(train)
                return false
            end
        else
            return false
        end
        index = index + 1
    end
    return true
end

def set_route_points_signals(var route)
    # Set points
    for var point in route.points
        # position can be normal/reserve
        if exec set_point_aspect(point, point.position)
            return false
        end
    end

    # Set entry signal to green (proceed aspect)
    if exec set_signal_aspect(route.source, green)
        return false
    end

    return true
end