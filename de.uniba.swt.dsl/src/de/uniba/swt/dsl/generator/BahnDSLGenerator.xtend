/*
 * generated by Xtext 2.20.0
 */
package de.uniba.swt.dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import de.uniba.swt.dsl.bahnDSL.ModuleObject
import de.uniba.swt.dsl.bahnDSL.BoardsProperty
import de.uniba.swt.dsl.bahnDSL.SegmentsProperty
import de.uniba.swt.dsl.bahnDSL.SignalsProperty
import de.uniba.swt.dsl.bahnDSL.AspectsProperty
import de.uniba.swt.dsl.bahnDSL.PointsProperty
import de.uniba.swt.dsl.bahnDSL.TrainsProperty
import de.uniba.swt.dsl.generator.models.*
import java.util.Set
import de.uniba.swt.dsl.generator.models.NetworkModel

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BahnDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var e = resource.contents.get(0)
		if (e instanceof ModuleObject) {
			var network = new NetworkModel()
			network.name = e.name
			for (property : e.properties) {
				switch property {
					// aspects
					AspectsProperty:
						network.aspects = convertAspects(property)	
					BoardsProperty:
						network.boards = convertBoards(property)
					SegmentsProperty:
						network.segments = convertSegments(property)
					SignalsProperty:
						network.signals = convertSignals(property)
					PointsProperty:
						network.points = convertPoints(property)
					TrainsProperty:
						network.trains = convertTrains(property)
				}
			}
			
			// bidib_board_config
			fsa.generateFile("bidib_board_config.yml", compileBoardConfig(network.boards))
			
			// bidib_track_config
			fsa.generateFile("bidib_track_config.yml", compileTrackConfig(network.segments, network.signals, network.points))
			
			// bidib_train_config
			fsa.generateFile("bidib_train_config.yml", network.trains.compileTrainConfig)
		}
	}
	
	def compileBoardConfig(Set<Board> boards) {
		val builder = new StringBuilder("# BiDiB board configuration").append("\n")
		builder.append("boards:").append("\n")
		for (b: boards) {
			var prefix = "  ";
			builder.append(prefix).append("- id: " + b.id).append("\n");
			builder.append(prefix).append("  unique-id: " + b.uniqueId.hexString).append("\n")
			if (b.features !== null && b.features.size > 0) {
				prefix += "  ";
				for (f: b.features) {
					builder.append(prefix).append("- number: " + f.number.hexString).append("\n")
					builder.append(prefix).append("  value: " + f.value.hexString).append("\n")
				}
			}
		}
		return builder.toString
	}
	
	def compileBoardConfig(NetworkModel model) '''
		# BiDiB board configuration
		boards:
		«FOR b:model.boards»
		  «"  "»- id: «b.id»
		  «"    "»unique-id: «b.uniqueId.hexString»
		    «IF b.features !== null && b.features.size > 0»
		  «"    "»features:
		    «FOR f: b.features»
		    «"    "»- number: «f.number.hexString»
		    «"      "»value: «f.value.hexString»
		    «ENDFOR»
		    «ENDIF»
		«ENDFOR»
	'''
	
	def compileTrackConfig(Set<Segment> segments, Set<Signal> signals, Set<Point> points) '''
		# Track configuration
		boards:
		«IF segments !== null && segments.size > 0»
		  - id: «segments.get(0).boardId»
		    segments:
		    «FOR s:segments»
		    - id: «s.id»
		    address: «s.address.hexString»
		    «ENDFOR»
		«ENDIF»
		«IF signals !== null && signals.size > 0»
		  - id: «signals.get(0).boardId»
		  	signals-board:
		  	  «FOR s:signals»
		  	  - id: «s.id»
		  	  number: «s.number.hexString»
		  	  «ENDFOR»
		«ENDIF»
		«IF points !== null && points.size > 0»
		  - id: «points.get(0).boardId»
		  	points-board:
		  	«FOR p:points»
		  	- id: «p.id»
		  	number: «p.number.hexString»
		  	«ENDFOR»
		«ENDIF»
	'''
	
	def compileTrainConfig(Set<Train> trains) '''
		# Train configuration
		trains:
		«FOR t:trains»
		  - id: «t.id»
		    dcc-address: «t.dccAddress.hexString»
		«ENDFOR»
	'''
		
	def convertAspects(AspectsProperty property) {
		return property.items.map[p | new Aspect(
			p.id,
			p.value.longValue
		)].toSet
	}
		
	def convertBoards(BoardsProperty property) {
		return property.items.map[p | new Board(
			p.id,
			p.uniqueId.longValue,
			null
		)].toSet
	}
	
	def convertSegments(SegmentsProperty property) {
		return property.items.map[p | new Segment(
			p.id,
			property.boardId,
			p.address.longValue
		)].toSet
	}
	
	def convertSignals(SignalsProperty property) {
		return property.items.map[p | new Signal(
			p.id,
			property.boardId,
			p.number.longValue,
			null,
			null
		)].toSet
	}
	
	def convertPoints(PointsProperty property) {
		return property.items.map[p | new Point(
			p.id,
			property.boardId,
			p.number.longValue,
			null,
			null
		)].toSet
	}
	
	def convertTrains(TrainsProperty property) {
		return property.items.map[p | new Train(
			p.id,
			p.address.longValue
		)].toSet
	}
	
	def getLongValue(String value) {
		if (value !== null && value.toLowerCase.startsWith("0x")) {
			return Long.parseLong(value.substring(2), 16)
		}
		
		return 0
	}
	
	def hexString(long value) {
		return "0x" + (value < 16 ? "0" : "") + Long.toHexString(value).toUpperCase
	}
}