/*
 * generated by Xtext 2.20.0
 */
package de.uniba.swt.expr.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import de.uniba.swt.expr.bahnexpr.BahnExpr
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.eclipse.emf.ecore.EClass
import de.uniba.swt.expr.bahnexpr.BahnexprFactory
import de.uniba.swt.expr.services.BahnExprGrammarAccess
import de.uniba.swt.expr.bahnexpr.BahnexprPackage

@ExtendWith(InjectionExtension)
@InjectWith(BahnExprInjectorProvider)
class BahnExprValidationTest {
	@Inject extension ParseHelper<BahnExpr>
	@Inject extension ValidationTestHelper

	@Test
	def void testCallMainError() {
		'''
		    def main()
		        plus()
		    end
		    def plus()
		    	main()
		    end
		'''.parse.assertError(BahnexprPackage.Literals.FUNCTION_CALL_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to FuncDecl 'main'")
	}

	@Test
    def void testCallUndefinedFunc() {
        '''
            def main()
                func1()
            end
        '''.parse.assertError(BahnexprPackage.Literals.FUNCTION_CALL_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to FuncDecl 'func1'")
    }

    @Test
    def void testCallValidFunc() {
        '''
            def main()
                plus(1, -2)
            end
            def plus(int a, int b)
                return a + b
            end
        '''.parse.assertNoErrors
    }
    
    @Test
    def void testValuedRefInvalidVarDecl() {
        '''
            def plus(int a, int b)
                return a + b + c
            end
        '''.parse.assertError(BahnexprPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'c'")
    }
    
    @Test
    def void testValuedRefInvalidCrossParamDecl() {
        '''
			def plus(int a, int b)
				return a + b
			end
			def main()
				plus(a, -2)
			end
        '''.parse.assertError(BahnexprPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'a'")
    }
    
    @Test
    def void testValuedRefInvalidCrossVarDecl() {
        '''
			def plus(int a, int b)
				int c = a + b
				return c
			end
			def main()
				plus(c, -2)
			end
        '''.parse.assertError(BahnexprPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'c'")
    }
    
    @Test
    def void testArithmeticOpExprType() {
        '''
			def main()
				int a1 = false + 1
			end
        '''.parse.assertError(BahnexprPackage.Literals.OP_EXPRESSION, null, "Expected int or float")
    }
    
    @Test
    def void testLogicalOpExprType() {
        '''
			def main()
				bool a1 = false || 3
			end
        '''.parse.assertError(BahnexprPackage.Literals.OP_EXPRESSION, null, "Expected bool")
    }
    
    @Test
    def void testEqualityOpExprType() {
        '''
			def main()
				bool a1 = 3 == true
			end
        '''.parse.assertError(BahnexprPackage.Literals.OP_EXPRESSION, null, "Expressions must have the same type")
    }
    
    @Test
    def void testRelationalOpExprType() {
        '''
			def main()
				bool a1 = false > true
			end
        '''.parse.assertError(BahnexprPackage.Literals.OP_EXPRESSION, null, "Expected int or float")
    }
    
    @Test
    def void testTypeVarDeclStmt() {
        '''
			def main()
				int n = true
			end
        '''.parse.assertError(BahnexprPackage.Literals.VAR_DECL_STMT, null, "Expression has type bool")
    }
    
    @Test
    def void testTypeAssignmentStmt() {
        '''
			def main()
				bool b = false
			    b = 4
			end
        '''.parse.assertError(BahnexprPackage.Literals.ASSIGNMENT_STMT, null, "Expression has type int")
    }
    
    @Test
    def void testTypeVarDeclStmtWithOpExpr() {
        '''
			def main()
				int n3 = true && false
			end
        '''.parse.assertError(BahnexprPackage.Literals.VAR_DECL_STMT, null, "Expression has type bool")
    }
    
    @Test
    def void testTypeSelectionStmt() {
        '''
			def main()
				if 3
			        int i1 = 1
			    end
			end
        '''.parse.assertError(BahnexprPackage.Literals.SELECTION_STMT, null, "Expected bool")
    }
    
    @Test
    def void testTypeFunctionCallExpr() {
        '''
			def plus(int a, int b): int
			    return a + b
			end
			
			def main()
			    bool c = plus(3, 4)
			end
        '''.parse.assertError(BahnexprPackage.Literals.VAR_DECL_STMT, null, "Expression has type int")
    }
}
