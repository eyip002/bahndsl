grammar de.uniba.swt.dsl.Bahn with de.uniba.swt.expr.BahnExpr

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate bahn "http://www.uniba.de/swt/dsl/Bahn"
import "http://www.uniba.de/swt/expr/BahnExpr" as bahnexpr


ModuleObject:
	'module' name=ID
		(properties+=ModuleProperty)*
	'end';
	
ModuleProperty:
	AspectsProperty 
	| BoardsProperty 
	| SegmentsProperty 
	| SignalsProperty 
	| PointsProperty 
	| BlocksProperty 
	| TrainsProperty 
	| LayoutProperty 
	| PlatformProperty
	| RouteProperty
	| FuncDeclsProperty
	;

AspectsProperty :
	{AspectsProperty} 'aspects'
		(items+=AspectElement)*
	'end';
BoardsProperty :
	{BoardsProperty} 'boards'
		(items+=BoardElement)*
	'end';
SegmentsProperty :
	'segments' board=[BoardElement]
		(items+=SegmentElement)*
	'end';
SignalsProperty :
	'signals' board=[BoardElement]
		(items+=SignalElement)*
	'end';
PointsProperty :
	'points' board=[BoardElement]
		(items+=PointElement)*
	'end';
BlocksProperty :
	{BlocksProperty} 'blocks'
		(items+=BlockElement)*
	'end';
TrainsProperty :
	{TrainsProperty} 'trains'
		(items+=TrainElement)*
	'end';
LayoutProperty :
	{LayoutProperty} 'layout'
		(items+=LayoutElement)*
	'end';
PlatformProperty :
	{PlatformProperty} 'platforms'
		(items+=PlatformElement)*
	'end';
RouteProperty:
	{RouteProperty} 'routes'
		(items+=RouteElement)*
	'end';
	
FuncDeclsProperty:
	{FuncDeclsProperty} decls+=FuncDecl
;

@Override 
FunctionCallExpr returns bahnexpr::FunctionCallExpr:
	super | GetFuncExpr | WaitFuncExpr | GrantRouteFuncExpr | SetAspectFuncExpr
;

GetFuncExpr returns BExpression:
	{GetFuncExpr} 'get'
	(
		aspectObjectType=AspectObjectType aspectObjectId=PrimaryExpr
	|
		getRoute?='route from' srcSignalExpr=PrimaryExpr 'to' destSignalExpr=PrimaryExpr
	)
;

WaitFuncExpr returns BExpression:
	{WaitFuncExpr} 'wait' 'for' value=INT timeSpan=TimeSpanType
;

GrantRouteFuncExpr returns BExpression:
	{GrantRouteFuncExpr} 'grant' routeExpr=PrimaryExpr 'to' trainExpr=PrimaryExpr
;

SetAspectFuncExpr returns BExpression:
	{SetAspectFuncExpr} 
	'set' aspectObjectType=AspectObjectType objectExpr=PrimaryExpr 'to' aspectExpr=PrimaryExpr
;

enum TimeSpanType:
	SECONDS = 'seconds' | MINUTES = 'minutes' | HOURS = 'hours'
;

enum AspectObjectType:
	POINT = 'point' | SIGNAL = 'signal'
;

@Override
EqualityExpr returns Expression:
	{EqualityExpr}leftExpr=RelationalExpr suffix=BEqualityExprSuffix?
;

BEqualityExprSuffix:
	op=BEqualityOperator
	(
		occupiedBy?='occupied by'? rightExpr=RelationalExpr
	|
		routeAvailable?='available'
	|
		occupied?='occupied'
	)
;

BEqualityOperator:
	'is' isNot?='not'?
;
	
PlatformElement: 
	name=ID block=[BlockElement]
;

RouteElement:
	name=ID 
	'source' source=[SignalElement] 
	'destination' destination=[SignalElement] 
	'direction' direction=DIRECTION 
	'path' (segments+=[SegmentElement])* 'end'
	'points' points+=RoutePoint 'end'
	'signals' signals+=[SignalElement] 'end'
	'conflicts' conflicts+=[RouteElement] 'end'
;

RoutePoint:
	point=[PointElement] aspect=ID
;
		
enum TrainType:
	CARGO='cargo' | PASSENGER='passenger'
;

AspectElement :
	name=ID value=HEX
;

BoardElement :
	name=ID uniqueId=HEX ('features' (features+=BoardFeatureElement)+ 'end')?
;

BoardFeatureElement:
	number=HEX ':' value=HEX
;

SegmentElement :
	name=ID address=HEX
;

SignalElement :
	name=ID number=HEX 'aspects' aspects=SignalAspectsElement 'end' 'initial' initial=[AspectElement] 
;

SignalAspectsElement:
	ReferenceSignalAspectsElement | OverrideSignalAspectsElement
;

ReferenceSignalAspectsElement:
	(aspects+=[AspectElement])+
;

OverrideSignalAspectsElement:
	(aspects+=AspectElement)+
;

PointElement :
	name=ID number=HEX 
		'block' block=[BlockElement] 
		'normal' normalAspect=PointAspectElement 
		'reverse' reverseAspect=PointAspectElement 
		'initial' initial=PointAspectType
;

PointAspectElement:
	value=HEX ':' block1=[BlockElement] '--' block2=[BlockElement]
;

enum PointAspectType:
	NORMAL = 'normal' | REVERSE = 'reverse'
;

BlockElement :
	name=ID 
		(hasStart?='buffer' ':' startSeg=[SegmentElement] ',' startSignal=ID directionStart=DIRECTION)?  
		'main' ':' mainSeg=[SegmentElement] 
		(directionEnd=DIRECTION hasEnd?='buffer' ':' endSeg=[SegmentElement] ',' endSignal=[SignalElement])?
		('length' length=Length)?
		('trains' (trainTypes+=TrainType)+ 'end')?
;

TrainElement :
	name=ID address=HEX 
		'steps' steps=INT
		('calibration' (calibrations+=INT)+ 'end')?
		('weight' weight=Weight)?
		('type' type=TrainType)?
		('peripherals' (peripherals+=PeripheralElement)+ 'end')?
;

PeripheralElement:
	name=ID 'bit' bit=INT 'initial' initial=INT
;

LayoutElement :
	blocks+=[BlockElement] ('--' blocks+=[BlockElement])*
;

Length:
	value=INT unit=LengthUnit
;

enum LengthUnit:
	CENTIMETRE = 'cm' | METRE = 'm' | KILOMETRE = 'km'
;

Weight:
	value=INT unit=WeightUnit
;

enum WeightUnit:
	GRAM = 'g' | KILOGRAM = 'kg'| TON = 't'
;

enum DIRECTION:
	Clockwise='->' | AntiClockwise='<-' | Bidirectional='<->'
;

@Override
terminal HEX returns ecore::ELong:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')+;