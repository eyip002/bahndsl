module SWTbahn1
    # interlocking procedure - required
    def interlocking_procedure(interlockingtable, source_signal, destination_signal, train)
        var route = interlocking_table_get_route(source_signal, destination_signal)
        if route == nil
            return nil
        end
        
        var not_grantable = route_is_unavailable_or_conflicted(interlockingtable, route)
        if not_grantable
            return nil
        end
        
        var is_clear = route_is_clear(route, train)
        if !is_clear
            return nil
        end
        
        block_route(route, train)
        set_route_points_signals(route)
        return route
    end

    def route_is_unavailable_or_conflicted(route)
        # Check if the route has been granted (unavailable)
        if route.train != nil
            return true

        # Check conflicts
        for item in route.conflicts
            if item.train != nil
                return true
            end
        end

        return false
    end

    def route_is_clear(route, train)
        # Signal at the route source has to be red (stop aspect)
        if get_signal_aspect(route.source) != red
            return false
        end

        # Signals of tracks that intersect the route have to be red (stop aspect)
        for signal in route.signals
            if get_signal_aspect(signal) != red
                return false
            end
        end

        # All track segments on the route have to be clear
        var index = 0
        for segment in route.path
            var data = get_segment_data(segment)
            if data.occupied
                # Only the first track segment can be occupied, and only by the requesting train
                if index == 0 && data.dcc_address_cnt == 1
                    var query_train = get_train(data.dcc_addresses[0])
                    if query_train != train
                        return false;
                    end
                else
                    return false;
                end
            end
            index = index + 1
        end
        return true
    end

    def block_route(route, train)
        route.train = train
    end

    def set_route_points_signals(route)
        # Set points
        for point in route.points
            if !switch_point(point.point, point.position)
                # Execute route: Set point - invalid parameters
                return false
            end
        end

        # Set entry signal to green (proceed aspect)
        if !set_signal(route.source, green)
            # Set signal - invalid parameters
            return false
        end

        return true
    end

    # Built-in functions
    external def interlocking_table_get_route(interlockingtable, source_signal, destination_signal)
    external def get_signal_aspect(signal)
    external def get_segment_data(segment)
    external def get_train(dcc_address)
    external def switch_point(point, aspect)
    external def set_signal(signal, aspect)
end