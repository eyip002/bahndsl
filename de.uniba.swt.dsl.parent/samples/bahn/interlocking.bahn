module interlocking
    # interlocking procedure - required
    def interlocking_procedure(var source_signal, var destination_signal, var train)
        var route1 = get route from source_signal to destination_signal
        if route1 is nil
            return nil
        end
        
        var not_grantable = route_is_unavailable_or_conflicted(route)
        if not_grantable
            return nil
        end
        
        var is_clear = route_is_clear(route, train)
        if !is_clear
            return nil
        end
        
        # block route
        grant route1 to train

        # set points and signals
        set_route_points_signals(route1)
        
        return route
    end

    def route_is_unavailable_or_conflicted(var route1)
        # Check if the route has been granted (unavailable)
        if route1 is not available
            return true
        end

        # Check conflicts
        for var item in route.conflictRoutes
            if item.train is not nil
                return true
            end
        end

        return false
    end

    def route_is_clear(var route1, var train)
        # TODO Signal at the route source has to be red (stop aspect)
        # if get route entry signal is red
        #     return false
        # end

        # TODO Signals of tracks that intersect the route have to be red (stop aspect)
        # for var flankSignal in flank route signals
        #     if get signal is not red
        #         return false
        #     end
        # end

        # All track segments on the route have to be clear
        int index = 0
        for var seg in route.paths
            if seg is occupied
                if index is 0 && seg is not occupied by train
                    return false
                end
            else
                return false
            end
            index = index + 1
        end
        return true
    end

    def set_route_points_signals(var route1)
        # Set points
        for var pt in route.routePoints
            if get point pt.position is normal
                set point pt to normal
            else
                set point pt to reverse
            end
        end

        # Set entry signal to green (proceed aspect)
        if set signal route.srcSignal to green
            # Set signal - invalid parameters
            return false
        end

        return true
    end
end