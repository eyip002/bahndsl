grammar de.uniba.swt.expr.BahnExpr with org.eclipse.xtext.common.Terminals

generate bahnexpr "http://www.uniba.de/swt/expr/BahnExpr"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

BahnExpr:
	{BahnExpr} (decls+=FuncDecl)*
;

FuncDecl:
	'def' name=ID ('()' | '(' paramDecls+=ParamDecl (',' paramDecls+=ParamDecl)* ')') (return?=':' returnType=DataType)?
		stmtList=StatementList
	'end'
;

StatementList:
	{StatementList} (stmts+=Statement)*
;

Statement:
	SelectionStmt | IterationStmt | VarDeclStmt | AssignmentStmt | FunctionCallStmt | ReturnStmt
;

SelectionStmt returns Statement:
	{SelectionStmt} 'if' expr=Expression
	thenStmts=StatementList
	(=>'else'
		elseStmts=StatementList
	)?
	'end'
;

IterationStmt returns Statement:
	{IterationStmt} 'for' var=VarDecl 'in' referenceExpr=ValuedReferenceExpr
		stmts=StatementList
	'end'
;

VarDeclStmt returns Statement:
	{VarDeclStmt} decl=VarDecl assignment=VariableAssignment
;

VarDecl:
	{VarDecl} type=DataType name=ID (array?='[' cardinality=Expression ']')?
;

ParamDecl:
	{ParamDecl} type=DataType name=ID array?='[]'?
;

RefVarDecl:
	VarDecl | ParamDecl
;

AssignmentStmt returns Statement:
	{AssignmentStmt} referenceExpr=ValuedReferenceExpr assignment=VariableAssignment
;

FunctionCallStmt returns Statement:
	{FunctionCallStmt} expr=FunctionCallExpr
;

ReturnStmt returns Statement:
	{ReturnStmt}'return' expr=Expression
;

VariableAssignment:
	'=' ('{' arrExprs+=Expression (',' arrExprs+=Expression)* '}' | expr=Expression)
;

Expression:
	LogicalOrExpr
; 

LogicalOrExpr returns OpExpression:
	LogicalAndExpr ({OpExpression.leftExpr=current} op=OrOp rightExpr=LogicalAndExpr)* 	
;

LogicalAndExpr returns OpExpression:
	EqualityExpr ({OpExpression.leftExpr=current} op=AndOp rightExpr=EqualityExpr)*
;

EqualityExpr returns OpExpression:
	RelationalExpr ({OpExpression.leftExpr=current} op=EqualityOp rightExpr=RelationalExpr)*
;

RelationalExpr returns OpExpression:
	AdditiveExpr ({OpExpression.leftExpr=current} op=RelationalOp rightExpr=AdditiveExpr)*
;

AdditiveExpr returns OpExpression:
	MultiplicativeExpr ({OpExpression.leftExpr=current} op=PlusMinusOp rightExpr=MultiplicativeExpr)*
;

MultiplicativeExpr returns OpExpression:
	PrimaryExpr ({OpExpression.leftExpr=current} op=MulDivOp rightExpr=PrimaryExpr)*
;

PrimaryExpr:
    UnaryExpr
	| ParenthesizedExpr
	| LiteralExpr
	| ValuedReferenceExpr
	| FunctionCallExpr
;

UnaryExpr:
	{UnaryExpr} '!' expr=PrimaryExpr
;

ParenthesizedExpr:
	'(' expr=Expression ')'
;

LiteralExpr:
	BooleanLiteral
	| NumberLiteral
	| HexLiteral
	| StringLiteral
	| NullLiteral
;

ValuedReferenceExpr:
	decl=[RefVarDecl]
		('['indices+=Expression']')* 
		('.' propRef=ValuedReferenceExpr)?
;

FunctionCallExpr:
	{FunctionCallExpr}
	decl=[FuncDecl] ('()' | '(' params+=Expression (',' params+=Expression)* ')')
;

BooleanLiteral returns LiteralExpr:
	{BooleanLiteral} boolValue=BOOLEAN
;

NumberLiteral:
	{NumberLiteral} value=NUMBER
;

HexLiteral:
	{HexLiteral} value=HEX	
;

StringLiteral:
	{StringLiteral} value=STRING
;

NullLiteral:
	{NullLiteral} 'nil'
;

enum DataType:
	INT_TYPE='int' | FLOAT_TYPE = 'float' | BOOLEAN_TYPE = 'bool' | STRING_TYPE = 'string' | OBJECT_TYPE = 'var'
;

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;

enum PlusMinusOp returns OperatorType:
	PLUS = '+' | MINUS = '-'
;

enum MulDivOp returns OperatorType:
	MULTIPLY = '*' | DIVISION = '/'
;

enum OrOp returns OperatorType:
	OR = '||'
;

enum AndOp returns OperatorType:
	AND = '&&'
;

enum EqualityOp returns OperatorType:
	EQUAL='==' | NOT_EQUAL='!='
;

enum RelationalOp returns OperatorType:
	GREATER='>' | LESS='<' | GREATER_OR_EQUAL='>=' | LES_OR_EQUAL='<='
;

NUMBER returns ecore::EDouble:
	'-'? INT ('.' INT)?
;

terminal HEX returns ecore::ELong:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')+;

@Override 
terminal SL_COMMENT : '#' !('\n'|'\r')* ('\r'? '\n')?;

@Override
terminal STRING returns ecore::EString:
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"';