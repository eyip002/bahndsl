/*
 * generated by Xtext 2.20.0
 */
package de.uniba.swt.dsl.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import de.uniba.swt.dsl.bahn.RootModule
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import de.uniba.swt.dsl.bahn.BahnPackage

@ExtendWith(InjectionExtension)
@InjectWith(BahnInjectorProvider)
class BahnValidationTest {
	@Inject extension ParseHelper<RootModule>
	@Inject extension ValidationTestHelper

	@Test
    def void testCallUndefinedFunc() {
        '''
            module validation def interproc()
                func1()
            end end
        '''.parse.assertError(BahnPackage.Literals.FUNCTION_CALL_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to FuncDecl 'func1'")
    }

    @Test
    def void testCallValidFunc() {
        '''
            module validation
            def interproc()
                plus(1, -2)
            end
            def plus(int a, int b):int
                return a + b
            end end
        '''.parse.assertNoErrors
    }
    
    @Test
    def void testValuedRefInvalidVarDecl() {
        '''
            module validation def plus(int a, int b)
                return a + b + c
            end end
        '''.parse.assertError(BahnPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'c'")
    }
    
    @Test
    def void testValuedRefInvalidCrossParamDecl() {
        '''
			module validation
			def plus(int a, int b)
				return a + b
			end
			def interproc()
				plus(a, -2)
			end
			end
        '''.parse.assertError(BahnPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'a'")
    }
    
    @Test
    def void testValuedRefInvalidCrossVarDecl() {
        '''
			module validation
			def plus(int a, int b)
				int c = a + b
				return c
			end
			def interproc()
				plus(c, -2)
			end
			end
        '''.parse.assertError(BahnPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'c'")
    }
    
    @Test
    def void testArithmeticOpExprType() {
        '''
			module validation def interproc()
				int a1 = false + 1
			end end
        '''.parse.assertError(BahnPackage.Literals.OP_EXPRESSION, null, "Expected int or float")
    }
    
    @Test
    def void testLogicalOpExprType() {
        '''
			module validation def interproc()
				bool a1 = false || 3
			end end
        '''.parse.assertError(BahnPackage.Literals.OP_EXPRESSION, null, "Expected bool")
    }
    
    @Test
    def void testEqualityOpExprType() {
        '''
			module validation def interproc()
				bool a1 = 3 == true
			end end
        '''.parse.assertError(BahnPackage.Literals.OP_EXPRESSION, null, "Expressions must have the same type")
    }
    
    @Test
    def void testRelationalOpExprType() {
        '''
			module validation def interproc()
				bool a1 = false > true
			end end
        '''.parse.assertError(BahnPackage.Literals.OP_EXPRESSION, null, "Expected int or float")
    }
    
    @Test
    def void testTypeVarDeclStmt() {
        '''
			module validation def interproc()
				int n = true
			end end
        '''.parse.assertError(BahnPackage.Literals.VAR_DECL_STMT, null, "Expression has type bool")
    }
    
    @Test
    def void testTypeAssignmentStmt() {
        '''
			module validation def interproc()
				bool b = false
			    b = 4
			end end
        '''.parse.assertError(BahnPackage.Literals.ASSIGNMENT_STMT, null, "Expression has type int")
    }
    
    @Test
    def void testTypeVarDeclStmtWithOpExpr() {
        '''
			module validation def interproc()
				int n3 = true && false
			end end
        '''.parse.assertError(BahnPackage.Literals.VAR_DECL_STMT, null, "Expression has type bool")
    }
    
    @Test
    def void testTypeSelectionStmt() {
        '''
			module validation def interproc()
				if 3
			        int i1 = 1
			    end end
			end end
        '''.parse.assertError(BahnPackage.Literals.SELECTION_STMT, null, "Expected bool")
    }
    
    @Test
    def void testTypeFunctionCallExpr() {
        '''
			module validation
			def plus(int a, int b): int
			    return a + b
			end
			
			def interproc()
			    bool c = plus(3, 4)
			end end
        '''.parse.assertError(BahnPackage.Literals.VAR_DECL_STMT, null, "Expression has type int")
    }
    
    @Test
    def void testLayoutSwitch() {
		'''
			module test
				boards
					master 0x00
				end
				segments master
					seg1 0x00 length 11cm
				end
				blocks
					b1 main seg1
					b2 main seg1
					b3 main seg1
					p1 main seg1
				end
				layout
					b1.up -- p1.stem
				    b2.up -- p1.straight
				    b3.down -- p1.side
				end
			end
		'''.parse.assertNoErrors
	}
	
	@Test
	def void testLayoutCrossing() {
		'''
			module test
				boards
					master 0x00
				end
				segments master
					seg1 0x00 length 11cm
				end
				blocks
					b1 main seg1
					b2 main seg1
					b3 main seg1
					b4 main seg1
					p1 main seg1
				end
				layout
					b1.up -- p1.down1
				    b2.up -- p1.down2
				    b3.down -- p1.up1
				    b4.down -- p1.up2
				end
			end
		'''.parse.assertNoErrors
	}
	
	@Test
	def void testLayoutSignal() {
		'''
			module test
				aspects
					red 0x00
				end
				boards
					master 0x00
				end
				segments master
					seg1 0x00 length 11cm
				end
				signals master
					sig1 0x00 aspects red end initial red
				end
				blocks
					b1 main seg1
				end
				layout
				    sig1 -- b1.down
				end
			end
		'''.parse.assertNoErrors
	}
}
