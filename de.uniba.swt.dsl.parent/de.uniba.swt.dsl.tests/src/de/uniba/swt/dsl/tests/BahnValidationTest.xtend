/*
 * generated by Xtext 2.20.0
 */
package de.uniba.swt.dsl.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import de.uniba.swt.dsl.bahn.RootModule
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import de.uniba.swt.dsl.bahn.BahnPackage

@ExtendWith(InjectionExtension)
@InjectWith(BahnInjectorProvider)
class BahnValidationTest {
	@Inject extension ParseHelper<RootModule>
	@Inject extension ValidationTestHelper

	@Test
    def void testCallUndefinedFunc() {
        '''
            module validation def interproc()
                func1()
            end end
        '''.parse.assertError(BahnPackage.Literals.FUNCTION_CALL_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to FuncDecl 'func1'")
    }

    @Test
    def void testCallValidFunc() {
        '''
            module validation
            def interproc()
                plus(1, -2)
            end
            def plus(int a, int b)
                return a + b
            end end
        '''.parse.assertNoErrors
    }
    
    @Test
    def void testValuedRefInvalidVarDecl() {
        '''
            module validation def plus(int a, int b)
                return a + b + c
            end end
        '''.parse.assertError(BahnPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'c'")
    }
    
    @Test
    def void testValuedRefInvalidCrossParamDecl() {
        '''
			module validation
			def plus(int a, int b)
				return a + b
			end
			def interproc()
				plus(a, -2)
			end
			end
        '''.parse.assertError(BahnPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'a'")
    }
    
    @Test
    def void testValuedRefInvalidCrossVarDecl() {
        '''
			module validation
			def plus(int a, int b)
				int c = a + b
				return c
			end
			def interproc()
				plus(c, -2)
			end
			end
        '''.parse.assertError(BahnPackage.Literals.VALUED_REFERENCE_EXPR, "org.eclipse.xtext.diagnostics.Diagnostic.Linking", "Couldn't resolve reference to RefVarDecl 'c'")
    }
    
    @Test
    def void testArithmeticOpExprType() {
        '''
			module validation def interproc()
				int a1 = false + 1
			end end
        '''.parse.assertError(BahnPackage.Literals.OP_EXPRESSION, null, "Expected int or float")
    }
    
    @Test
    def void testLogicalOpExprType() {
        '''
			module validation def interproc()
				bool a1 = false || 3
			end end
        '''.parse.assertError(BahnPackage.Literals.OP_EXPRESSION, null, "Expected bool")
    }
    
    @Test
    def void testEqualityOpExprType() {
        '''
			module validation def interproc()
				bool a1 = 3 == true
			end end
        '''.parse.assertError(BahnPackage.Literals.OP_EXPRESSION, null, "Expressions must have the same type")
    }
    
    @Test
    def void testRelationalOpExprType() {
        '''
			module validation def interproc()
				bool a1 = false > true
			end end
        '''.parse.assertError(BahnPackage.Literals.OP_EXPRESSION, null, "Expected int or float")
    }
    
    @Test
    def void testTypeVarDeclStmt() {
        '''
			module validation def interproc()
				int n = true
			end end
        '''.parse.assertError(BahnPackage.Literals.VAR_DECL_STMT, null, "Expression has type bool")
    }
    
    @Test
    def void testTypeAssignmentStmt() {
        '''
			module validation def interproc()
				bool b = false
			    b = 4
			end end
        '''.parse.assertError(BahnPackage.Literals.ASSIGNMENT_STMT, null, "Expression has type int")
    }
    
    @Test
    def void testTypeVarDeclStmtWithOpExpr() {
        '''
			module validation def interproc()
				int n3 = true && false
			end end
        '''.parse.assertError(BahnPackage.Literals.VAR_DECL_STMT, null, "Expression has type bool")
    }
    
    @Test
    def void testTypeSelectionStmt() {
        '''
			module validation def interproc()
				if 3
			        int i1 = 1
			    end end
			end end
        '''.parse.assertError(BahnPackage.Literals.SELECTION_STMT, null, "Expected bool")
    }
    
    @Test
    def void testTypeFunctionCallExpr() {
        '''
			module validation
			def plus(int a, int b): int
			    return a + b
			end
			
			def interproc()
			    bool c = plus(3, 4)
			end end
        '''.parse.assertError(BahnPackage.Literals.VAR_DECL_STMT, null, "Expression has type int")
    }
}
